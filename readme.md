# Заметки

можно добавлять [метки на циклы](https://learn.javascript.ru/while-for#метки-для-break-continue), а потом делать breake или continue по ним



`/` в строке позволяет написать с новой строки, в выводе не виден  
`/` - экранирует  
`/ + n, t, ..` - вывод спец символов

### Преобрзовние к булеву типу 
`!!` перед переменной

### Преобразование к числу
* строгое `+`: 
```
var a = '443';
+a
```
* мягкое 

`parseInt(number , system)` -  преобразует строку в целое число до первого не числового символа

`parseFloat()` - аналогично, только с дробным, ошибка на второй точке

### Проверка на число 

`NaN !== NaN`

`isNaN()` - проверка  на NaN, `isFinite()` - проверка на infyity и NaN  

### Проверка на тип данных

1.  `typeof` - подходит для примитивов, кроме `null` и функций  
2.  `[[Class]]` - использование `{}.toString.call(obj).slice(8, -1);` возвращает подходит только только для встроенных объектов  
3.  `Array.isArray(arr)` - возвращает `true` только если `arr` – массив  
4.  `instanceof` - использование `user instanceof User`, возвращает `true || false`, даже учитывает наследование  
5.  "Утиная типизация" `«If it looks like a duck, swims like a duck and quacks like a duck, then it probably is a duck (who cares what it really is)».`

### Округление числа 
Округления числа побитовым оператором:  
`(12.34^0) = 12` - скобки нужны, т.к. приоритет у `^` маленький  

`Math.floor` - Округляет вниз  
`Math.ceil` -  Округляет вверх  
`Math.round` - Округляет до ближайшего целого  

--------------

`**` - возведение в степень `( 2 ** 3 == 8)`

Для поиска подстроки использовать:

`substr(start, [ ,length])`  
`slice(stast, [ , end])`

**Удобно для преобразования цветов:**
```
var n = 255;
alert( n.toString(16) ); // ff
```

**Случайное число в интервале:**  
`Math.random() * (max - min) + min` - дробное  
`Math.round(Math.random() * (max - min) + min)` - целое  

---------------  

## Объекты

`Object.assign(name, karma)` - копирует данные из объекта `name` в объект `karma`  
`Object.keys(user)` - массив ключей объекта `user`  
`Object.values(user)` - массив значений ключей объекта `user`  
`Object.entries(user)` - массив массивов полей `user` 

Можно удалить поле из объекта: `delete obj.name`  

Проверить существует ли поле в объекте:  
*оператор `in`: `'age' in obj`  
*прировнять к `undefined`  
*самое простое: `if(obj.age)`  

Проверка на объект: `typeof 'object' && !== null`, т.к. null выдает на `typeof => 'object'`


**Если имя свойства хранится в переменной, то обратиться к нему можно только через `[]`, не через точку.**  

**Массивы**
`Array.isArray(arr);` - проверка на массив

`arr.length=0` - очистка массива, так же можно задать длинну и укоротить его  

Метоты массивов:
![](/img/methods.png)

**Функции**

Есть встроенные методы у функций `foo`, например имеет `foo.name` - имя `foo` `foo.length` - количество параметров  

Замыкание - функция и ее лексическое окруженние  


`function foo (arg1, arg2, ...rest){}` - `...rest` - массив оставшихся незаданных параметров `rest` - название массива, может быть любым  

**Декоратор**

Принемает функцию и то что должно быть до и поле нее, возвращает до + результат функции + после  

```

function wrapperDecorator(f, before, after) {
	return function() {
		return before + f.apply(this, arguments) + end; // apply - для уневерсальности вызова
	};	
}

wrapperDecorator(getDay, '<div>', '</div>') // обернуть результат функции в div

```

**Преобразование объектов: `toString` и `valueOf`**

* Любой объект в логическом контексте – `true`, даже если это пустой массив `[]` или объект `{}`
* У большинства объектов нет `valueOf`, за исключением объекта Data, поэтому преобразование идет к строке  
* если есть + перед выражением (например +room), или операции с числами(-, /, *) берется преобразование `valueOf`, если его нет, то `toString`  
* Массивы - они же объекты имеют только строковое преобразование 
* Два объекта равны только тогда, когда это один и тот же объект  

**bing**

Вызов `bind` также позволяет фиксировать первые аргументы функции (**«каррировать»** её), и таким образом из общей функции получить её «частные» варианты – чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз.  

```
function mul(a, b) {
  return a * b;
};

// double умножает только на два
var double = mul.bind(null, 2); // контекст фиксируем null, он не используется
```
 
**Время**

`Date.now()` - секунды c 1970
`performance.now()` - cчитает доли секунды 

# Ресурсы 

* [доки по Markdown](https://github.com/OlgaVlasova/markdown-doc/blob/master/README.md#Lines)
* [доки по emmet(ускореное написание)](https://docs.emmet.io/cheat-sheet/)
* [как писать документацию к коду](http://usejsdoc.org/)
* [доки по Веб-технологим(в частности JS)](https://developer.mozilla.org/ru/docs/Web/JavaScript)
